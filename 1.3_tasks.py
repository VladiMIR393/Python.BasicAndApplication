# step_9
# Напишите реализацию функции closest_mod_5, принимающую в качестве единственного аргумента
# целое число x и возвращающую самое маленькое целое число y, такое что:
#      y больше или равно x
#      y делится нацело на 5

def closet_mod_5(x):
    if x % 5 == 0:
        return x
    else:
        y = (x//5 + 1)*5
        print(x//5)
        return y
print(closet_mod_5(-10))
print(closet_mod_5(-13))
print(closet_mod_5(-21))


#-----------------------------------------------------------------------------------------------
"""
Сочетанием из n элементов по k называется подмножество этих n элементов размера k.
Два сочетания называются различными, если одно из сочетаний содержит элемент, который 
не содержит другое. Числом сочетаний из n по k называется количество различных сочетаний из n по k. 
Обозначим это число за C(n, k).

Пример:
Пусть n = 3, т. е. есть три элемента (1, 2, 3). Пусть k = 2.
Все различные сочетания из 3 элементов по 2: (1, 2), (1, 3), (2, 3).
Различных сочетаний три, поэтому C(3, 2) = 3.

Несложно понять, что C(n, 0) = 1, так как из n элементов выбрать 0 можно единственным образом, 
а именно, ничего не выбрать. Также несложно понять, что если k > n, то C(n, k) = 0, так как невозможно,
например, из трех элементов выбрать пять.

Для вычисления C(n, k) в других случаях используется следующая рекуррентная формула:
C(n, k) = C(n - 1, k) + C(n - 1, k - 1).
------------------------------------------------------------------------------------------------------
Реализуйте программу, которая для заданных n и k вычисляет C(n, k).

Вашей программе на вход подается строка, содержащая два целых числа n и k (1 ≤ n ≤ 10, 0 ≤ k ≤ 10).
Ваша программа должна вывести единственное число: C(n, k).

"""
#------------------------------------------------------------------------------------------------

n, k = map(int, input().split())
def C(n,k):
    if k==0:
        return 1
    elif k > n:
        return 0
    else:
        return C(n-1,k) + C(n-1,k-1)
print(C(n,k))